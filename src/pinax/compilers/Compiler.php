<?php
/**
 * This file is part of the PINAX framework.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */


abstract class pinax_compilers_Compiler extends PinaxObject
{
	var $_fileName	= NULL;
	var $_cacheObj	= NULL;
	var $output 	= '';
	var $cacheDetails;

	function __construct($cacheDir=null, $lifeTime=null)
	{
		$options = array(
			'cacheDir' => $cacheDir ? $cacheDir : pinax_Paths::get('CACHE_CODE'),
			'lifeTime' => is_null($lifeTime) ?
							 (class_exists('__Config') ? __Config::get('CACHE_CODE') : 0)
							 :
							 $lifeTime,
            'hashedDirectoryLevel' => (class_exists('__Config') ? __Config::get('CACHE_CODE_DIR_LEVEL') : 0),
			'readControlType' => '',
			'fileExtension' => '.php'
		);

		$this->_cacheObj = &pinax_ObjectFactory::createObject('pinax.cache.CacheFile', $options);
	}

	function initOutput()
	{
		$this->output = '';
		$this->output .= '<?php'.PNX_COMPILER_NEWLINE2;
		$this->output .= 'if (!defined(\'PNX_LOADED\')) exit();'.PNX_COMPILER_NEWLINE2;
		$this->output .= '// ------------------------------------------------------------------------------'.PNX_COMPILER_NEWLINE2;
		$this->output .= '// This code is generated by PINAX ('.get_class($this).') based on the source file'.PNX_COMPILER_NEWLINE2;
		$this->output .= '// '.$this->_fileName.PNX_COMPILER_NEWLINE2;
		$this->output .= '// date: '.date('m/d/Y H:i:s').PNX_COMPILER_NEWLINE2;
		$this->output .= '// ------------------------------------------------------------------------------'.PNX_COMPILER_NEWLINE2;
		$this->output .= '// Cache path: ' . $this->cacheDetails['cachePath'] .PNX_COMPILER_NEWLINE2;
		$this->output .= '// Group prefix: ' . $this->cacheDetails['groupPrefix'] .PNX_COMPILER_NEWLINE2;
		$this->output .= '// Class name: ' . $this->cacheDetails['className'] .PNX_COMPILER_NEWLINE2;
		$this->output .= '// Request URL: ' . $this->cacheDetails['requestUrl'] .PNX_COMPILER_NEWLINE2;
		$this->output .= '// Query string: ' . $this->cacheDetails['queryString'] .PNX_COMPILER_NEWLINE2;
		$this->output .= '// User agent: ' . $this->cacheDetails['userAgent'] .PNX_COMPILER_NEWLINE2;
		$this->output .= '// ------------------------------------------------------------------------------'.PNX_COMPILER_NEWLINE2;
	}

	function save()
	{
		$charset = pinax_charset();
		$this->_cacheObj->save( strtolower($charset) != 'utf-8' ? utf8_decode( $this->output ) : $this->output, NULL, pinax_Paths::get('CACHE').get_class($this));
		$fileName = $this->_cacheObj->getFileName();
		if (function_exists('opcache_invalidate')) {
			opcache_invalidate($fileName, true);
		}
		return $fileName;
	}

	abstract function compile($options);

	/**
	*	Verifica se il file è compilato, in casi affermativo restutuisce il path
	*/
	function verify($fileName, $options=NULL)
	{
		// $fileName = realpath( $fileName );
		// check if the file is already compiled in the same request
		// this is usefull in develop enviroment
		$c = pinax_ObjectValues::get($this->getClassName(), $fileName);
		if (!is_null($c))
		{
			return $c;
		}

		// può essere passato un nome di file per verificare
		// il caching. è utilizzato nel reamp dei pageType
		$verifyFileName = $options && isset($options['verifyFileName']) ? $options['verifyFileName'] : $fileName;
		$groupPrefix = $options && isset($options['groupPrefix']) ? $options['groupPrefix'] : '';
		$this->cacheDetails = [
			'cachePath' => pinax_Paths::get('CACHE'),
			'groupPrefix' => $groupPrefix,
			'className' => get_class($this),
			'requestUrl' => ((!empty($_SERVER['HTTPS']) and $_SERVER['HTTPS'] == 'on') ? 'https' : 'http') . '://' . $_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI'],
			'queryString' => $_SERVER['QUERY_STRING'],
			'userAgent' => $_SERVER['HTTP_USER_AGENT']
		];
		$cacheFileName = $this->_cacheObj->verify($verifyFileName, pinax_Paths::get('CACHE').$groupPrefix.get_class($this));
		if ($cacheFileName===false)
		{
			$this->_fileName = $fileName;
			$cacheFileName = $this->compile( $options );
			if ($cacheFileName===false)
			{
				// TODO
				echo "FATAL ERROR ".$fileName;
				return false;
			}
		}

		pinax_ObjectValues::set($this->getClassName(), $fileName, $cacheFileName);
		return $cacheFileName;
	}

	function isValid( $fileName )
	{
		$fileName = realpath( $fileName );
		// check if the file is already compiled in the same request
		// this is usefull in develop enviroment
		$c = pinax_ObjectValues::get($this->getClassName(), $fileName);
		if (!is_null($c))
		{
			return true;
		}

		$cacheFileName = $this->_cacheObj->verify($fileName, pinax_Paths::get('CACHE').get_class($this));
		return $cacheFileName!==false;
	}


	public function invalidate()
	{
		$this->_cacheObj->clean(pinax_Paths::get('CACHE').get_class($this));
		$this->_cacheObj->clean(pinax_Paths::get('CACHE').__Session::get('pinax.editingLanguage').get_class($this));
	}
}
